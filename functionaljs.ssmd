= [Functional Javascript](http://bit.ly/T7iIiw)
== Wat?!
_


= Why Functional?
_


=== Write Better Code
^Greater Confidence^
Testable code promotes reliable re-writing and can be objectively ensured to have fewer bugs. Who wants to fix code that was thought to already be fixed?
^Increased Productivity^
Safe, stable code can be relied on and you can move onto other things.
^Easier Comprehension^
Shorter, more focused, code is easier to grasp for yourself and other developers.
_


= SO!
== What does it all mean?
_


= Moar Laziness!
_


= Hooked?
== Good, now some boring stuff.
_


=== Agenda
# Introduction
#* Why Javascript?
#* Programming Paradigms
# Functional Programming Concepts
#* Functional Javascript snippets
# Code Refactoring Examples
# Questions
_

<!--
* Teach myself - basically I don't care about any of you
_-->


==+ Me
* Front-end engineer for [@QuickenLoans](http://twitter.com/@QuickenLoans)
* website [JoshuaKalis.com](http://joshuakalis.com)
* twitter.com/[@kalisjoshua](http://twitter.com/kalisjoshua)

==== Brief experience time-line
# Started as a Graphic Designer, NOT a programmer
# Moved to Web Design through images first then CSS and HTML
# Picked up ASP Classic
# Forced to learn Javascript (HATED all of it!)
# Learned a little of these: PHP4, C# .NET 2.0, Java
# Began to LOVE Javascript
All self-taught mostly.
_


= Hi, my name is Josh.
== I <3 Javascript. I might be biased.
_


=== Javascript has a LOT of BAD parts!
* Variables are free to be overwritten at any time
* Type coercion within equality checks are unreliable
* The 'this' value can be tricky for n00bs (as well as everyone else from time to time)
* Blocks are optional for control structures
* Switch fall-through
* The 'arguments' object inside function calls
* Automatic semi-colon insertion
* The difference in function statements and expressions
* Misunderstood misused constructs: eval, with, continue, void
* Typed wrappers: new Boolean(true), new Number(9), new Array(), etc.
* new (necessary at times but...)
* Unused reserved words
* Unicode
* The typeof operator is in accurate
* Floating point numbers: 0.1 + 0.2 !== 0.3 // true
* The plus (+) operator for [addition concatenation infix]
* Hoisting
* NaN... Nyan cat?
* and (many) more... :(
_


=== What is there to love about Javascript?
* Ubiquitous
** It's almost everywhere
** Setup is done for you
* Forgiving
** Making mistakes might still achieve the goal you want
** Easy to start programming
* Useful
** People like having interactive web pages
** Employable skill
* Multi-paradigm
** Write however you want
* and more (probably) but lets move on
_


==+ Main Programming Paradigms ([source](http://people.cs.aau.dk/~normark/prog3-03/html/notes/paradigms_themes-paradigm-overview-section.html))
* Imperative, Procedural, or Structured - 1954 FORTRAN
** "First do this and next do that"
* Object Oriented - 1960s Simula 67
** "Send messages between objects to simulate the temporal evolution of a set of real world phenomena"
* Functional - 1960s LISP
** "Evaluate an expression and use the resulting value for something"
* Others? - [yes, there are lots](http://en.wikipedia.org/wiki/Programming_paradigm#Programming_paradigms)
_


=== Imperative
---
var message = 'Hello ';
var promptMessage = 'What is your name?';
var name = prompt(promptMessage);
alert(message + name);
---
# Set some variables
# Ask the user for their name and store that to a variable
# Finally we greet them with a message including their name.
Do we see the 'Procedure' here?
    "... describes computation in terms of statements that change a program state." ~~ [wikipedia](http://en.wikipedia.org/wiki/Imperative_programming)
_


=== Object Oriented
---
function Greeting (name) {                     // class instance initialization
    this.name = name;
}
Greeting.promptMessage = 'What is your name?'; // static(-like) property
Greeting.prototype.say = function (message) {  // inherited function
    alert(message + this.name);
}
var name = prompt(Greeting.promptMessage);
var user = new Greeting(name);
user.say('Hello ');
---
Here we gain some re-usability, albeit with some verbosity.
# Define a 'class'; see the quotes, because Javascript doesn't truly have classes.
#* Added a 'static' property; that is publicly available
#* Added a type-based method; prototypically inherited by all instances
# Create an instance of the 'class' with an instance variable of the user's name.
# Greet the user with a message including their name.
_

<!--
=== I write non-functional Javascript
Just to set you at ease, I am not a functional Javascript doyen writing everything in a functional manner. Actually, from time to time, I even write Javascript that doesn't even function.
---
function myAwesomeness (arg) {
    // perform some intense computation on arg
    // fully unit tested
    // purely functional
    // return some computed value
}
// ...
var myVar = myAwesomeness(); // derp derp
---
_
-->


=== Fair Warning
Functional Programming might infect your brain and change the way that you think about problems. You might find yourself re-evaluating old code and saying something similar to:
    "The small experience I've had with #Haskell is already changing the way I write #JavaScript, mostly regarding avoiding side effects." ~~ [@tlhunter](https://twitter.com/tlhunter/status/262648059442376704 )
_


==+ What is Functional?
    "In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data. It emphasizes the application of functions, in contrast to the imperative programming style, which emphasizes changes in state. Functional programming has its roots in lambda calculus, a formal system developed in the 1930s to investigate function definition, function application, and recursion. Many functional programming languages can be viewed as elaborations on the lambda calculus." ~~ [wikipedia](http://en.wikipedia.org/wiki/Functional_programming)
_


= That's Boring!
== And what...?
_


=== What does functional mean?
Here are the topics I found to be most talked about within the FP research that I performed for this talk.
* Purity
* Functions as Values
* Higher Order Functions
* Closure
* Currying
* Partial Application
* Composition
* Lazy Evaluation
* Continuations
* Continuation Passing Style (CPS)
_


=== Impurity
Relying on side effects leads to problems and brain-ache.
---
var sum = 0;
function addToSum (a) {
    sum += a;
    return sum;
}
addToSum(1); // returns 1
addToSum(2); // returns 3
sum = 0;
addToSum(3); // returns 3 -> WTF!
---
Now this code is reliant on a lot of things happening as intended such as no one changing sum directly. It is also less reliably testable.
_


=== Purity
* Referential transparency - for a (input) value x there is a (output) value y
* Treats computation as the evaluation of mathematical functions
* AVOIDS state and mutable data; doesn't necessarily eliminate it
---
function sum (a, b) {
    return a + b;
}
// ...
sum(1, 2); // returns 3, every time.
---
This is referentially transparent, meaning it can be logically reasoned about and the input dictates the output. Testing this will be straight-forward and reliable.
_


=== Functions as values
* A function is a 'value' (object or thing) that can be assigned to an 'identifier' (or variable)
This declaration:
---
function add (a, b) {
    return a + b;
}
---
... is very similar to this expression:
---
var add = function add (a, b) {
    return a + b;
}
---
The only difference being when they are initialized in the Javascript interpreter. The end result is the same; a function identified as 'add'.
    "Function Expressions and Functional Programming are inseparable." ~~ [JavaScript JavaScript](http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/)
_


=== Higher Order Functions
* Takes a function as an argument (or)
* Returns a function as a result
Examples: map, filter, forEach/each, some, every, click, focus, load, keydown, ... etc.
==== Functions as arguments
---
$('a#clicker')
    .on('click', function (event) {
        event.preventDefault();
        alert('oh yeah!');
    });
---
_


=== Higher Order Functions (cont.)
Examples: ajax, bind, event handlers, array functions, 'factories', others...
^Functions as returned values^
---
// add factory
function makeAdder (baseValue) {
    return function (x) {
        return baseValue + x;
    };
}
var add5 = makeAdder(5);
add5(10);   // returns 15
add5(1000); // returns 1005
add5(-4);   // returns 1
---
or...
---
function add (a, b) {
    return a + b;
}
var add5 = add.bind(null, 5); // partial function application 'topic coming soon'
---
_


=== IIFE - Immediately Invoked Function Expression
And now for a little (Algebraic) Substitution. The two equations below are equal.
* 3 * (1 + 2) = 9
* 3 * (3) = 9
---
var add = function (a, b) {return a + b;};
add(1, 2); // returns 3 every time

// Baby step, remember from math class, parens are just grouping
(add)(1, 2); // returns 3 every time

// Here is the IIFE
(function (a, b) {return a + b;})(1, 2); // returns 3 every time
---
_


=== Closure (lexical scoping)
Objects retain access to the context (scope) in which they were created
---
var outterObj = (function () {
    var hidden = 'I have a secret.';

    return {
        get: function () {
            return hidden;
        }
        , set: function (newValue) {
            hidden = newValue;
        }
    };
}());

outterObj.get();  // returns 'I have a secret.'
outterObj.set('Javascript is awesome!');
outterObj.get();  // returns 'Javascript is awesome!'
outterObj.hidden; // undefined
---
_


=== Scope Chain
Let's take a little side step for a second. Behold the ASCII diagram.
+++
program execution drills down through scopes
          &darr;
+-------------------+
|    Global Scope   |
|-------------------|
| Namespace Context | &larr; single global namespace object (omitted)
|-------------------|
|    IIFE Context   | &larr; innerObj is assigned to myObject through closure
|-------------------|
|        ...        |
|-------------------|
|  Binding Context  | &larr; functions can have a binding context
|-------------------|
| Execution Context | &larr; myObj.get has privileged access to hidden
+-------------------+
          &uarr;
variable resolution looks up the scope chain until hitting global
+++
_


=== Currying
    "...transforming a function that takes n multiple arguments [into] a chain of functions, each with a single argument..." ~~ [wikipedia](http://en.wikipedia.org/wiki/Currying)
This might take some explanation to fully grasp; it did for me anyway.
---
function sumOfSix (a, b, c, d, e, f) {
    return a + b + c + d + e + f;
}
// ...
sumOfSix(1, 2, 3); // some argument values will be undefined
// ...
                   // curry is a fictitious function here
var sumOfSixCurried = curry(sumOfSix);
sumOfSixCurried(1);       // returns a new function expecting one argument
sumOfSixCurried(1)(2);    // returns a new function expecting one argument
sumOfSixCurried(1)(2)(3); // returns a new function expecting one argument
sumOfSixCurried(1)(2)(3)(4)(5)(6); // returns 21
---
_


=== Partial Application
Reducing the number of arguments by applying others previously.
---
function add (a, b) {
    return a + b;
}
var add5 = add.bind(null, 5);
add5(10); // returns 15
add5(-4); // returns 1
---
The bind method of the Function object allows us to do two things: explicitly set the context a function will execute with; value of 'this' inside the function, and supply arguments that will be available in the function body.
[Partial Application in JavaScript by Ben Alman](http://benalman.com/news/2012/09/partial-application-in-javascript/)
<!---
// !WARNING! unsafe for actual use
function partial (fn) {
    var args = [].slice.call(arguments, 1);     // get all arguments after the first
    return function () {
        fn.apply(null, args.concat(arguments)); // add args to partially applied args
    }
}
--->
_


=== Composition
A new function that, when called, will pass the output of one function call as the input of the next and so on through all functions in the composition.
---
function fnA (_) { return _ + 2; }
function fnB (_) { return _ * 3; }
function fnC (_) { return _ - 5; }
// ...
var resultA = fnA(7);           // 9
var resultB = fnB(resultA);     // 27
var resultC = fnC(resultB);     // 22
// or
var result = fnC(fnB(fnA(7)));  // 22
---
with composition:
---
var compositionABC = compose(fnA, fnB, fnC);
var result = compositionABC(7);             // 22
// ...
var map = [13, 17, 23].map(compositionABC); // [40, 52, 70]
---
Composition reduces the number of times the list is iterated over from once per function in the composition to just once. Benefits: reusable, passable, composable, testable, scalable etc.
_


=== Lazy evaluation
Known as Generators, Sequences, or Streams ([StreamJS](http://streamjs.org/)), these constructs only return values on-demand. Collections of infinite length are actually workable without enormous processing power or infinite system memory.
---
// native Javascript array (not lazy)
var jsArray = [1,2,3,4,5,6,7,8,9];
jsArray.length;  // returns 9
---
Lazy evaluated structures will work quite a bit differently.
---
// using Stream.js library
var simple = Stream.range(); // create a stream of natural numbers [1,2,3...&infin;]
simple.length(); // returns... umm, infinitely loops as it attempts to find the end

simple.take(10).length(); // returns 10
---
Checkout Stream and do some cool things. I would love to see it!
_


=== Continuations
Continuations are not possible in Javascript. [http://idea-log.blogspot.com/](http://idea-log.blogspot.com/2005/10/why-are-continuations-so-confusing-and.html)
Think of the old "goto" statements of yore but add in the fact that state of computation/execution is kept.
    "[a reification of] an instance of a computational process at a given point in the process's execution" ~~ [http://eriwen.com/](http://eriwen.com/javascript/cps-tail-call-elimination/)
Javascript does not support Continuations natively; however, the Rhino environment does provide them as first-class objects.
* Resume execution with pre-existing state
_


=== Continuation-Passing Style (CPS)
Commonly used as callbacks in Javascript land.
---
doAJAX(
    'http://url.to.api'
  , JSON.stringify({name: 'Joshua'})
  , function succesHandler (data) {/*do cool stuff*/}
  , function failHandler  (error) {/*do cool stuff*/});
---
Possible stack overflow problems for deeply nested calls due to no tail optimization.
    "No procedure is allowed to return to its caller ever..." ~~ [By example: Continuation-passing style in JavaScript](http://matt.might.net/articles/by-example-continuation-passing-style/)
_


=== Functional Elsewhere?
We can gain some of the benefits that Functional offers us by just working in that way.
    "Programming in a functional style can also be accomplished in languages that aren't specifically designed for functional programming." ~~ [wikipedia](http://en.wikipedia.org/wiki/Functional_programming)
* Avoid reliance on state transformations
* Write functions side affect free
* Prefer composition over inheritance
_


= Example Time!
_


= #FunctionalJS
== Go, now, and be functional
_


=== Further Learning
* Point Free
* Monads
_


=== Resources
# [Functional Programming - Wikipedia](http://en.wikipedia.org/wiki/Functional_programming)
# [Functional Programming For The Rest of Us](http://www.defmacro.org/ramblings/fp.html)
# [Pure, functional JavaScript](http://cjohansen.no/talks/2012/sdc-functional/#1)
# [Stream.js](http://streamjs.org/)
# [Functional Programming - igstan.ro](http://igstan.ro/files/functional-programming.pdf)
# [Function Declarations vs. Function Expressions](http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/)
# [By example: Continuation-passing style in JavaScript](http://matt.might.net/articles/by-example-continuation-passing-style/)
# [Continuation-Passing Style](http://marijnhaverbeke.nl/cps/)
# [lz](https://github.com/goatslacker/lz)
# [http://idea-log.blogspot.com/](http://idea-log.blogspot.com/2005/10/why-are-continuations-so-confusing-and.html)
# [Overview of the four main programming paradigms](http://people.cs.aau.dk/~normark/prog3-03/html/notes/paradigms_themes-paradigm-overview-section.html)
_


= Joshua T Kalis
== August 2012
_
